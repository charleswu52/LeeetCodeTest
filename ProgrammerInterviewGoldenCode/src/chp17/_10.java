package chp17;

/**
 * @author WuChao
 * @since 2021/6/6 下午12:37
 */
public class _10 {
    /**
     * 程序员面试金典(version 6) -  面试题 17.10. 主要元素
     * 难度: easy
     * <p>
     * 数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。
     * <p>
     * 示例:
     * 输入：[1,2,5,9,5,9,5,5,5]
     * 输出：5
     * <p>
     * 输入：[3,2]
     * 输出：-1
     * <p>
     * 输入：[2,2,1,1,1,2,2]
     * 输出：2
     * <p>
     * 进阶
     * 你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗
     * <p>
     * 数据范围：
     */

    /*
    题目解析：
    题目很简单，但如何在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成才是做本题的意义所在。
    思考一会不知道该用什么思路来做。

     */
    /*
    参考题解：使用福尔摩斯投票法
    使用福尔摩斯投票法来完成，福尔摩斯投票法思路如下：
        设置一个投票记录器：count，初始值为 0，代表没投票呢。
        然后设置前一个候选人 prev，初始值为 -1，代表还没产生有效票呢。
        接着顺序遍历数组，

        如果 count == 0 ，那么说明之前的票全部清空了，从当前开始重新计数，count++，prev = i
        否则的话，如果 prev == i ，那么说明前一个投的票和现在这个投的是同一个人，那么就 count++
        上述两条都不符合的话，就说明产生了新的候选人投票，就把前一个 count--，意思就是把前一个人的候选票 -1 相抵消
        最后，如果 count > 0 也得检查是不是真的超过了数组长度的二分之一。

     */
    public int majorityElement(int[] nums) {
        // prev 用来记录上一个有效的投票人，count用来记录他的有效投票数
        int prev = -1, count = 0;
        for (int i : nums) {
            // 如果 count == 0，说明之前的都抵消掉了，从新开始
            if (count == 0) {
                count++;
                prev = i;
            } else if (prev == i) {
                // 说明遇到了相同的投票，直接相加就好了
                count++;
            } else {
                // 说明遇到了不同的，那么就抵消掉一票
                --count;
            }
        }
        // 检查个数是不是真的超过了 1/2
        if (count > 0) {
            int n = 0;
            for (int i : nums) if (i == prev) n++;
            if (n > nums.length / 2) return prev;
        }
        return -1;
    }


}
