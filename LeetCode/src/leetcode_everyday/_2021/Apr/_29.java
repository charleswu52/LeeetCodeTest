package leetcode_everyday._2021.Apr;

/**
 * @author WuChao
 * @since 2021/4/29 下午7:05
 */
public class _29 {
    /**
     * 每日一题：2021/4/29
     * 403. 青蛙过河
     * 难度: hard
     * <p>
     * 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。
     * 青蛙可以跳上石子，但是不可以跳入水中。
     * <p>
     * 给你石子的位置列表 stones（用单元格序号 升序 表示），请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。
     * <p>
     * 开始时，青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。
     * <p>
     * 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。
     * 另请注意，青蛙只能向前方（终点的方向）跳跃。
     *
     *
     * <p>
     * 示例：
     * 输入：stones = [0,1,3,5,6,8,12,17]
     * 输出：true
     * 解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子,
     * 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子,
     * 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。
     * <p>
     * 数据范围：
     * 2 <= stones.length <= 2000
     * 0 <= stones[i] <= 231 - 1
     * stones[0] == 0
     */


    /*
    思路：使用动态规划的方法，令dp[i][k]表示青蛙现在所处的石头编号为i且上一次跳跃距离为k的状态
    状态转移方程：dp[i][k]=dp[j][k−1]⋁dp[j][k]⋁dp[j][k+1]
    式中 j 代表了青蛙的「上一次所在的石子编号」，满足 stones[i] - stones[j] = k。
    状态转移的初始条件为  dp[0][0]=true，表示：「现在所处的石子编号」为 0（石子从 0 开始编号），「上一次跳跃距离」为 0
    （这样可以保证青蛙的第一次跳跃距离为 11）。
    当我们找到一个 dp[n−1][k] 为真时，我们就知道青蛙可以到达终点（第 n-1  个石子）。

    对于第 i 个石子，我们首先枚举所有的 j（即上一次所在的石子编号），那么「上一次跳跃距离」k 即为
     stones[i] - stones[j]。如果在第 j 个石子上，青蛙的「上一次跳跃距离」可以为 k-1,k,k+1 三者之一，
     那么我们此时的方案即为合法方案。
     因此我们只需要检查 dp[j][k−1],dp[j][k],dp[j][k+1] 是否有至少一个为真即可。
     */

    /*
    优化
    为了优化程序运行速度，我们还将推出两个结论，并做出优化：
        1. 「现在所处的石子编号」为 i 时，「上一次跳跃距离」k 必定满足   k≤i
            当青蛙位于第 0 个石子上时，青蛙的上一次跳跃距离限定为 00，之后每次跳跃，青蛙所在的石子编号至少增加 1，而每次跳跃距离至多增加 1。
            跳跃 m 次后，青蛙「现在所处的石子编号」i≥m，「上一次跳跃距离」k≤m，因此 k≤i。
            这样我们可以将状态数约束在 O(n^2)
            我们可以从后向前枚举「上一次所在的石子编号」j，当「上一次跳跃距离」k 超过了 j+1 时，我们即可以停止跳跃，
            因为在第 j 个石子上我们至多只能跳出 j+1 的距离。

        2. 当第 i 个石子与第 i−1 个石子距离超过 i 时，青蛙必定无法到达终点。
            由结论 1 可知，当青蛙到达第 i−1 个石子时，它的「上一次跳跃距离」至多为 i−1，因此青蛙在第 i 个石子上最远只能跳出 i 的距离。
            而距离第 i-1 个石子最近的石子即为第 i 个石子，它们的距离超过了青蛙当前能跳出的最远距离，因此青蛙无路可跳。
            因此我们可以提前检查是否有相邻的石子不满足条件，如果有，我们可以提前返回 false。

     */
    public boolean canCross(int[] stones) {
        int n = stones.length;
        boolean[][] dp = new boolean[n][n];
        dp[0][0] = true;
        for (int i = 1; i < n; ++i) {
            if (stones[i] - stones[i - 1] > i) {
                return false;
            }
        }
        for (int i = 1; i < n; ++i) {
            for (int j = i - 1; j >= 0; --j) {
                int k = stones[i] - stones[j];
                if (k > j + 1) {
                    break;
                }
                dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];
                if (i == n - 1 && dp[i][k]) {
                    return true;
                }
            }
        }
        return false;
    }
}
