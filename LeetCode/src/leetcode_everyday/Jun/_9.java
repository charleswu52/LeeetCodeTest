package leetcode_everyday.Jun;

/**
 * @author WuChao
 * @create 2021/6/9 上午8:20
 */
public class _9 {
    /**
     * 每日一题：2021/6/9
     * 879. 盈利计划
     * 难度: hard
     * <p>
     * 集团里有 n 名员工，他们可以完成各种各样的工作创造利润。
     * <p>
     * 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。
     * <p>
     * 工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。
     * <p>
     * 有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。
     *
     * <p>
     * 示例:
     * 输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
     * 输出：2
     * 解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
     * 总的来说，有两种计划。
     * <p>
     * 输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
     * 输出：7
     * 解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
     * 有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。
     * <p>
     * 数据范围：
     * 1 <= n <= 100
     * 0 <= minProfit <= 100
     * 1 <= group.length <= 100
     * 1 <= group[i] <= 100
     * profit.length == group.length
     * 0 <= profit[i] <= 100
     */

    /*
    思路：动态规划
    总结背包问题的解法：
    1. 列出问题中变量
    2. 写出所求的问题
    3. 分析出和第2步里边问题直接相关的变量，作为dp数组的最后一维
    4. 把除了上一步之外的其它参数按容易理解的方式排列，构造dp数组
    5. 遍历参数逐步计算出最后结果

    本题思路：
    问题涉及到的变量：项目数(包含需要的人数和收益两个子变量)、人数、收益
        a: 项目数
            a1: 项目需要人数
            a2: 项目的收益
        b: 人数
        c: 收益

    所求问题：满足最小收益的方案数
    从第二步可以看到，和所求问题直接相关的是收益，所以dp数组的最后一维就是c(收益)
    剩下的就是两个变量是a(项目数)和b(人数)，单纯从理解来说谁在前面都行，不过因为这道题里边a(项目)这个参数比较复杂，
        里边还包含a1(项目需要人数)和a2(项目收益)两个子变量，而且a1(项目需要人数)这个参数和参数b(人数)还有关系，
        所以要把a(项目数)放到第一维，这样dp数组就构造出来了

    dp[项目数][人数][收益] = 方案数

      注意：实际操作中可以通过去掉dp数组的第一个维度，从而节省内存，这是因为状态转移过程里边只会用到前一轮的结果，而且遍历的顺序是固定的。直接用
    dp[人数][收益] = 方案数

    通过遍历求解就行了，思路是：
        先设置起始条件，就是：一共有0个项目，0个人，0收益的方案数是1
        然后用起始条件一点一点做遍历就行了，比如：
        有一个项目需要2个人能收益100元(假设总人数大于2)，现在2个人收益100元的项目就有1种方案了
    也就是dp[2][100] += dp[2 - 2][100 - 100]

    依次迭代下去就出来最后结果了

    注意：dp里边的人数是指正好用多少个人，而总方案是只要人够用就行，所以最后要把符合收益的所有人数的结果加起来

    另外，模运算(%)是个耗时的元算，不过这个问题里边每次都是两个小于MOD的数相加之后再对MOD取模，这就等价于相加之后如果比MOD大，然后减一个MOD就行


     */
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int mod = 1000000000 + 7;
        int length = group.length;

        int[][] dp = new int[n + 1][minProfit + 1];
        dp[0][0] = 1;
        for (int i = 0; i < length; i++) {
            int g = group[i];   // 项目人数
            int p = profit[i];  // 项目收益
            for (int j = n; j >= g; j--) {
                for (int k = minProfit; k >= 0; k--) {
                    dp[j][k] += dp[j - g][Math.max(k - p, 0)];
                    if (dp[j][k] > mod) {
                        dp[j][k] -= mod;
                    }

                }

            }

        }
        int res = 0;
        for (int i = 0; i <= n; i++) {
            res += dp[i][minProfit];
            if (res > mod) {
                res -= mod;

            }
        }
        return res;

    }
}
