/**
 * @author WuChao
 * @since 2021/3/27 上午10:47
 */
public class _56_1 {
    /**
     * 剑指 Offer 56 - I. 数组中数字出现的次数
     * 难度: medium
     * <p>
     * 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
     *
     * <p>
     * 例如：
     * 输入：nums = [4,1,4,6]
     * 输出：[1,6] 或 [6,1]
     *
     * <p>
     * 数据范围：
     * 2 <= nums.length <= 10000
     */

    /*
    题目解析: 本问题的难度在于要满足规定的时间复杂度O(n)与空间复杂度O(1)

     */

    /**
     * 思路:使用异或分组
     * 由于数组中存在着两个数字不重复的情况，我们将所有的数字异或操作起来，
     * 最终得到的结果是这两个数字的异或结果：(相同的两个数字相互异或，值为0)) 最后结果一定不为0，因为有两个数字不重复。
     * 因此需要做到是将数组中出现的两个不同的数给分到两组中，那如何分组的问题就成了难点：
     * 1.重复的数字进行分组，很简单，只需要有一个统一的规则，就可以把相同的数字分到同一组了。
     * 例如：奇偶分组。因为重复的数字，数值都是一样的，所以一定会分到同一组！
     * 2.此时的难点在于，对两个不同数字的分组。
     * 此时我们要找到一个操作，让两个数字进行这个操作后，分为两组。
     * 我们最容易想到的就是 & 1 操作， 当我们对奇偶分组时，容易地想到 & 1，即用于判断最后一位二进制是否为 1。来辨别奇偶。
     * <p>
     * 通过 & 运算来判断一位数字不同即可分为两组，那么我们随便两个不同的数字至少也有一位不同吧！
     * 我们只需要找出那位不同的数字mask，即可完成分组（ & mask ）操作。
     * <p>
     * 由于两个数异或的结果就是两个数数位不同结果的直观表现，所以我们可以通过异或后的结果去找 mask！
     * 所有的可行 mask 个数，都与异或后1的位数有关。
     * <p>
     * 为了操作方便，我们只去找最低位的mask:
     *
     * @param nums
     * @return
     */

    public int[] singleNumbers(int[] nums) {

        // 用于将所有的数异或起来
        int k = 0;

        // k是所有数异或的结果，由于只有两个数不同，所以k实际上是数组中那两个不同数字异或的结果
        for (int num : nums) {
            k ^= num;
        }
        // 对异或的结果找到最低位的mask
        int mask = 1;//获得最低位的1
        while ((k & mask) == 0) {
            mask <<= 1;
        }

        int a = 0, b = 0;// 结果
        for (int num : nums) {
            if ((num & mask) == 0) {
                a ^= num;
            } else {
                b ^= num;
            }
        }

        return new int[]{a, b};

    }
}
